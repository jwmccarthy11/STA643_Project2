mdprime <- min(d)
if(!is.null(Xorig)) {             ## new code
mdprime2 <- min(distance(X, Xorig))
if(mdprime2 < mdprime) mdprime <- mdprime2
}
if(mdprime > md) { md <- mdprime  ## accept
} else { X[row,] <- xold }        ## reject
}
return(X)
}
obj.alm <- function(x, gpi) {
-sqrt(predGP(gpi, matrix(x, nrow=1), lite=TRUE)$s2)
}
start <- maximin(ncol(X), nrow(X), Xorig=X)
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[2,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=0)
maximin_seq <- function(m, n, T=100000, Xorig=NULL)
{
X <- matrix(runif(n*m), ncol=m)     ## initial design
d <- distance(X)
d <- d[upper.tri(d)]
md <- min(d)
if(!is.null(Xorig)) {               ## new code
md2 <- min(distance(X, Xorig))
if(md2 < md) {
md <- md2
}
}
for(t in 1:T) {
row <- sample(1:n, 1)
xold <- X[row,]                   ## random row selection
X[row,] <- runif(m)               ## random new row
d <- distance(X)
d <- d[upper.tri(d)]
mdprime <- min(d)
if(!is.null(Xorig)) {             ## new code
mdprime2 <- min(distance(X, Xorig))
if(mdprime2 < mdprime) mdprime <- mdprime2
}
if(mdprime > md) {
md <- mdprime
} else {
X[row,] <- xold
}
}
return(X)
}
obj.alm <- function(XX, gpi) {
-sqrt(predGP(gpi, matrix(XX, nrow=1), lite=TRUE)$s2)
}
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[2,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=0)
library(lhs)
ninit <- 12
X <- randomLHS(ninit, 2)
f <- function(X, sd=0.01)
{
X[,1] <- (X[,1] - 0.5)*6 + 1
X[,2] <- (X[,2] - 0.5)*6 + 1
y <- X[,1] * exp(-X[,1]^2 - X[,2]^2) + rnorm(nrow(X), sd=sd)
}
y <- f(X)
y
library(lhs)
ninit <- 12
X <- randomLHS(ninit, 2)
f <- function(X, sd=0.01)
{
X[,1] <- (X[,1] - 0.5)*6 + 1
X[,2] <- (X[,2] - 0.5)*6 + 1
y <- X[,1] * exp(-X[,1]^2 - X[,2]^2) + rnorm(nrow(X), sd=sd)
}
y <- f(X)
library(laGP)
g <- garg(list(mle=TRUE, max=1), y)
d <- darg(list(mle=TRUE, max=0.25), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=TRUE)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), d$ab, g$ab)
mle
g
d
library(lhs)
ninit <- 12
X <- randomLHS(ninit, 2)
f <- function(X, sd=0.01)
{
X[,1] <- (X[,1] - 0.5)*6 + 1
X[,2] <- (X[,2] - 0.5)*6 + 1
y <- X[,1] * exp(-X[,1]^2 - X[,2]^2) + rnorm(nrow(X), sd=sd)
}
y <- f(X)
library(laGP)
g <- garg(list(mle=TRUE, max=1), y)
d <- darg(list(mle=TRUE, max=0.25), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=TRUE)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), d$ab, g$ab)
obj.alm <- function(x, gpi)
- sqrt(predGP(gpi, matrix(x, nrow=1), lite=TRUE)$s2)
obj.alm(X[1,],gpi)
obj.alm(X[2,],gpi)
obj.alm(X[3,],gpi)
f
y
X
plot(X)
# get obs, resp
y <- initial_df %>%
select(stress) %>%
pull()
y
# get obs, resp
y <- initial_df %>%
select(stress) %>%
pull()
# fit GP
g <- garg(NULL, y)
d <- darg(list(mle=TRUE), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=T)
length(y)
knitr::opts_chunk$set(echo=T,
message=F,
warning=F)
Sys.setenv(PATH=paste0(Sys.getenv("PATH"), ":/Applications/MATLAB_R2022a.app/bin"))
library(tidyverse)
library(plgp)
library(gridExtra)
library(ggpubr)
library(laGP)
# input ranges matrix
ranges <- tibble(
ymod=c(200e9, 300e9),
prat=c(0.1, 0.49),
cote=c(5e-6, 1.5e-5),
tcon=c(5, 15),
icat=c(50, 350),
plos=c(1e5, 4.8e5)
) %>%
`rownames<-`(c("lwr", "upr")) %>%
as.matrix()
lhs <- function(m, n) {
# generate the Latin hypercube
l <- (-(n - 1)/2):((n - 1)/2)
L <- matrix(NA, nrow=n, ncol=m)
for(j in 1:m) L[,j] <- sample(l, n)
# draw the random uniforms and turn the hypercube into a sample
U <- matrix(runif(n*m), ncol=m)
X <- (L + (n - 1)/2 + U)/n
# map to valid input ranges
# X <- X*rep(r[2,]-r[1,], each=n) + rep(r[1,], each=n)
# colnames(X) <- colnames(r)
# return the design
# return(list(X=X, g=c((l + (n - 1)/2)/n,1)))
return(X)
}
criterion <- function(X) {
d <- distance(X)
d <- d[upper.tri(d)]
min(d)
}
maximin <- function(m, n, T=100000)
{
X <- lhs(m, n)     ## initial design
md <- criterion(X)
for(t in 1:T) {
# select random column and pair of rows
rows <- sample(1:n, 2)
col <- sample(1:m, 1)
xold <- X[rows,col]
# swap values in row pair
X[rows,col] <- X[rev(rows),col]
# keep better arrangement
mdprime <- criterion(X)
if(mdprime > md) {
md <- mdprime                   ## accept
} else {
X[rows,col] <- xold             ## reject
}
}
return(X)
}
map_ranges <- function(X, ranges) {
X*rep(ranges[2,]-ranges[1,], each=nrow(X)) + rep(ranges[1,], each=nrow(X))
}
# number of initial runs
n <- 25
# get initial design
X <- maximin(6, n)
colnames(X) <- colnames(ranges)
init_design <- as.data.frame(map_ranges(X, ranges))
# sample projections
p1 <- init_design %>%
ggplot(aes(x=ymod, y=prat)) +
geom_point() +
labs(x="", y="", title="Young's Modulus vs. Poisson's Ratio") +
theme_bw()
p2 <- init_design %>%
ggplot(aes(x=cote, y=tcon)) +
geom_point() +
labs(x="", y="", title="Thermal Expansion vs. Conductivity") +
theme_bw()
p3 <- init_design %>%
ggplot(aes(x=icat, y=plos)) +
geom_point() +
labs(x="", y="", title="Cooling Air Temp. vs. Pressure Load") +
theme_bw()
p4 <- init_design %>%
ggplot(aes(x=ymod, y=plos)) +
geom_point() +
labs(x="", y="", title="Young's Modulus vs. Pressure Load") +
theme_bw()
grid.arrange(p1, p2, p3, p4, nrow=2)
simulate <- function(params) {
write.table(params, file="./x.csv", sep=",", row.names=F, col.names=F)
system("matlab -nodisplay -r \"run('./simulate.m'); exit\"",
ignore.stdout=T, ignore.stderr=T)
results <- read.csv("y.csv", header=F)
return(list(stress=results[1], displ=results[2]))
}
# stress <- c()
# displ  <- c()
#
# for (i in 1:nrow(init_design)) {
#   print(paste0("[Row ",i,"] Simulating..."))
#   results <- simulate(init_design[i,])
#   stress  <- c(stress, results$stress)
#   displ   <- c(displ, results$displ)
#   print(paste0("[Row ",i,"] ", results$stress, ", ", results$displ))
# }
#
# initial_df <- init_design %>%
#   mutate(stress=unlist(stress),
#          displ=unlist(displ)) %>%
#   write.csv(., file="./initial.csv")
initial_df <- read.csv("./initial.csv")[,-1] %>%
mutate(fails=displ>1.3e-3)
# sample projections
p1 <- initial_df %>%
ggplot(aes(x=ymod, y=prat, color=fails, size=stress)) +
geom_point() +
labs(x="", y="", title="Young's Modulus vs. Poisson's Ratio") +
theme_bw() +
scale_color_manual(values=c("seagreen3", "salmon")) +
labs(color="Fails") +
theme(legend.position="bottom") +
guides(size=F)
p2 <- initial_df %>%
ggplot(aes(x=cote, y=tcon, color=fails, size=stress)) +
geom_point() +
labs(x="", y="", title="Thermal Expansion vs. Conductivity") +
theme_bw() +
scale_color_manual(values=c("seagreen3", "salmon")) +
labs(color="Fails") +
theme(legend.position="bottom") +
guides(size=F)
p3 <- initial_df %>%
ggplot(aes(x=icat, y=plos, color=fails, size=stress)) +
geom_point() +
labs(x="", y="", title="Cooling Air Temp. vs. Pressure Load") +
theme_bw() +
scale_color_manual(values=c("seagreen3", "salmon")) +
labs(color="Fails") +
theme(legend.position="bottom") +
guides(size=F)
p4 <- initial_df %>%
ggplot(aes(x=ymod, y=plos, color=fails, size=stress)) +
geom_point() +
labs(x="", y="", title="Young's Modulus vs. Pressure Load") +
theme_bw() +
scale_color_manual(values=c("seagreen3", "salmon")) +
labs(color="Fails") +
theme(legend.position="bottom") +
guides(size=F)
ggarrange(p1, p2, p3, p4, nrow=2, ncol=2, common.legend=T, legend="bottom")
# get obs, resp
y <- initial_df %>%
select(stress) %>%
pull()
# fit GP
g <- garg(NULL, y)
d <- darg(list(mle=TRUE), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=T)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), g$ab, g$ab)
d
d <- darg(list(mle=TRUE, max=0.25), X)
d <- darg(list(mle=TRUE), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=T)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), g$ab, g$ab)
mle
g
d
maximin_seq <- function(m, n, T=100000, Xorig=NULL)
{
X <- matrix(runif(n*m), ncol=m)     ## initial design
d <- distance(X)
d <- d[upper.tri(d)]
md <- min(d)
if(!is.null(Xorig)) {               ## new code
md2 <- min(distance(X, Xorig))
if(md2 < md) {
md <- md2
}
}
for(t in 1:T) {
row <- sample(1:n, 1)
xold <- X[row,]                   ## random row selection
X[row,] <- runif(m)               ## random new row
d <- distance(X)
d <- d[upper.tri(d)]
mdprime <- min(d)
if(!is.null(Xorig)) {             ## new code
mdprime2 <- min(distance(X, Xorig))
if(mdprime2 < mdprime) mdprime <- mdprime2
}
if(mdprime > md) {
md <- mdprime
} else {
X[row,] <- xold
}
}
return(X)
}
obj.alm <- function(XX, gpi) {
-sqrt(predGP(gpi, matrix(XX, nrow=1), lite=TRUE)$s2)
}
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[2,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=0)
optim(start[3,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=0)
gpi
optim(start[3,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[3,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
# fit GP
g <- garg(list(mle=TRUE, max=1), y)
# fit GP
g <- garg(list(mle=TRUE), y)
d <- darg(list(mle=TRUE), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=T)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), g$ab, g$ab)
gpi
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[3,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
View(initial_df)
# get obs, resp
y <- initial_df %>%
select(stress) %>%
pull() / 10000
# fit GP
g <- garg(list(mle=TRUE), y)
d <- darg(list(mle=TRUE), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=T)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), g$ab, g$ab)
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[3,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[4,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[5,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[10,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[10,], obj=obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[10,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi, ...)
y
# get obs, resp
y <- initial_df %>%
select(stress) %>%
pull() / 1e10
y
# fit GP
g <- garg(list(mle=TRUE), y)
d <- darg(list(mle=TRUE), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=T)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), g$ab, g$ab)
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[10,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[9,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[10,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[1,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[24,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[23,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[22,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
start
# fit GP
g <- garg(list(mle=TRUE), y)
g
# get obs, resp
y <- initial_df %>%
select(stress) %>%
pull() / 1e9
# fit GP
g <- garg(list(mle=TRUE), y)
g
d
# get obs, resp
y <- initial_df %>%
select(stress) %>%
pull() / 1e9
# fit GP
g <- garg(list(mle=TRUE), y)
d <- darg(list(mle=TRUE), X)
gpi <- newGP(X, y, d=d$start, g=g$start, dK=T)
mle <- jmleGP(gpi, c(d$min, d$max), c(g$min, g$max), g$ab, g$ab)
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
optim(start[22,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[23,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[21,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[18,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
optim(start[1,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
start[1,]
optim(start, obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
for (i in 1:nrow(start)) {
print(optim(start[i,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)c$par)
print(optim(start[i,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)$par)
for (i in 1:nrow(start)) {
print(optim(start[i,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)$par)
}
xnew <- matrix(NA, nrow=nrow(X), ncol=ncol(X))
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
for (i in 1:nrow(start)) {
xnew[,i] <- optim(start[i,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)$par
}
xnew <- matrix(NA, nrow=nrow(X), ncol=ncol(X))
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
for (i in 1:nrow(start)) {
xnew[i,] <- optim(start[i,], obj.alm, method="L-BFGS-B", lower=0, upper=1, gpi=gpi)$par
}
plot(xnew[1,],xnew[2,])
plot(xnew[,1],xnew[,2])
plot(xnew[,1],xnew[,5])
plot(xnew[,3],xnew[,5])
plot(xnew[,4],xnew[,5])
plot(xnew[,4],xnew[,6])
plot(xnew[,1],xnew[,6])
xnew
View(xnew)
opt_search <- function(X, gpi, obj=obj.alm) {
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(start))
for(i in 1:nrow(start)) {
out <- optim(start[i,], obj, method="L-BFGS-B", lower=0,
upper=1, gpi=gpi, ...)
xnew[i,] <- c(out$par, -out$value)
}
solns <- data.frame(cbind(start, xnew))
names(solns) <- c("s1", "s2", "x1", "x2", "val")
return(solns)
}
opt_search <- function(X, gpi, obj=obj.alm) {
start <- maximin_seq(ncol(X)+1, nrow(X), Xorig=X)
xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(start))
for(i in 1:nrow(start)) {
out <- optim(start[i,], obj, method="L-BFGS-B", lower=0,
upper=1, gpi=gpi)
xnew[i,] <- c(out$par, -out$value)
}
solns <- data.frame(cbind(start, xnew))
return(solns)
}
opt_search(X, gpi)
X
opt_search <- function(X, gpi, obj=obj.alm) {
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(start)+1)
for(i in 1:nrow(start)) {
out <- optim(start[i,], obj, method="L-BFGS-B", lower=0,
upper=1, gpi=gpi)
xnew[i,] <- c(out$par, -out$value)
}
solns <- data.frame(cbind(start, xnew))
return(solns)
}
opt_search(X, gpi)
opt_search <- function(X, gpi, obj=obj.alm) {
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(start)+1)
for(i in 1:nrow(start)) {
out <- optim(start[i,], obj, method="L-BFGS-B", lower=0,
upper=1, gpi=gpi)
xnew[i,] <- c(out$par, -out$value)
}
return(xnew)
}
opt_search(X, gpi)
opt_search <- function(X, gpi, obj=obj.alm) {
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(start)+1)
for(i in 1:nrow(start)) {
out <- optim(start[i,], obj, method="L-BFGS-B", lower=0,
upper=1, gpi=gpi)
xnew[i,] <- c(out$par, -out$value)
}
xnew <- data.frame(xnew)
colnames(xnew) <- colnames(X)
return(xnew)
}
opt_search <- function(X, gpi, obj=obj.alm) {
start <- maximin_seq(ncol(X), nrow(X), Xorig=X)
xnew <- matrix(NA, nrow=nrow(start), ncol=ncol(start)+1)
for(i in 1:nrow(start)) {
out <- optim(start[i,], obj, method="L-BFGS-B", lower=0,
upper=1, gpi=gpi)
xnew[i,] <- c(out$par, -out$value)
}
xnew <- data.frame(xnew)
colnames(xnew) <- c(colnames(X), "var")
return(xnew)
}
opt_search(X, gpi)
xbest <- opt_search(X, gpi) %>%
as.data.frame() %>%
filter(var==min(var))
xupdt <- rbind(X, xbest)
xbest
xupdt <- rbind(X, xbest[1:6])
xupdt
