---
title: "HW3"
author: "Jack McCarthy"
date: "4/3/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=T)
```

```{r}
library(plgp)
library(tidyverse)
library(kableExtra)
```

# 3.

### (a)

```{r}
mylhs <- function(n, m)
{
  ## generate the Latin hypercube
  l <- (-(n - 1)/2):((n - 1)/2)
  L <- matrix(NA, nrow=n, ncol=m)
  for(j in 1:m) L[,j] <- sample(l, n)

  ## draw the random uniforms and turn the hypercube into a sample
  U <- matrix(runif(n*m), ncol=m)
  X <- (L + (n - 1)/2 + U)/n
  colnames(X) <- paste0("x", 1:m)

  ## return the design and the grid it lives on for visualization
  return(list(X=X, g=c((l + (n - 1)/2)/n,1)))
}
```

```{r}
maximin <- function(n, m, T=100000)
{
  X <- matrix(runif(n*m), ncol=m)     ## initial design
  d <- distance(X)
  d <- d[upper.tri(d)]
  md <- min(d)

  for(t in 1:T) {
    row <- sample(1:n, 1)
    xold <- X[row,]                   ## random row selection
    X[row,] <- runif(m)               ## random new row
    d <- distance(X)
    d <- d[upper.tri(d)]
    mdprime <- min(d)
    if(mdprime > md) { md <- mdprime  ## accept
    } else { X[row,] <- xold }        ## reject
  }

  return(X)
}
```

```{r}
criterion <- function(X) {
  d <- distance(X)
  d <- d[upper.tri(d)]
  min(d)
}
```

```{r}
mymaximin <- function(n, m, T=100000)
{
  X <- mylhs(n, m)$X     ## initial design
  md <- criterion(X)

  for(t in 1:T) {
    # row <- sample(1:n, 1)
    # xold <- X[row,]                   ## random row selection
    # X[row,] <- runif(m)               ## random new row
    rows <- sample(1:n, 2)
    col <- sample(1:m, 1)
    xold <- X[rows,col]
    X[rows,col] <- X[rev(rows),col]
    mdprime <- criterion(X)
    if(mdprime > md) { 
      md <- mdprime                   ## accept
    } else { 
      X[rows,col] <- xold             ## reject
    }
  }

  return(X)
}
```

```{r}
# 4D
crit.mmlhd.4 <- criterion(mymaximin(25, 4))
crit.lhd.4 <- 0
for (i in 1:100) {
  cand <- criterion(mylhs(25, 4)$X)
  if (cand > crit.lhd.4) {
    crit.lhd.4 <- cand
  }
}
crit.mm.4 <- criterion(maximin(25, 4))

# 3D
comb <- combn(1:4, 1)
dist.1 <- 0
dist.2 <- 0
dist.3 <- 0
best <- 0
for (i in 1:dim(comb)[2]) {
  dist.1 = dist.1 + criterion(mymaximin(25, 4)[,-comb[i]])
  dist.3 = dist.3 + criterion(maximin(25, 4)[,-comb[i]])
  for (i in 1:100) {
    cand <- criterion(mylhs(25, 4)$X[,-i])
    if (cand > best) {
      best <- cand
    }
  }
  dist.2 = dist.2 + best
}
crit.mmlhd.3 <- dist.1/dim(comb)[2]
crit.mm.3 <- dist.3/dim(comb)[2]
crit.lhd.3 <- dist.2/dim(comb)[2]

# 2D
comb <- combn(1:4, 2)
dist.1 <- 0
dist.2 <- 0
dist.3 <- 0
best <- 0
for (i in 1:dim(comb)[2]) {
  dist.1 = dist.1 + criterion(mymaximin(25, 4)[,-comb[i]])
  dist.3 = dist.3 + criterion(maximin(25, 4)[,-comb[i]])
  for (i in 1:100) {
    cand <- criterion(mylhs(25, 4)$X[,-i])
    if (cand > best) {
      best <- cand
    }
  }
  dist.2 = dist.2 + best
}
crit.mmlhd.2 <- dist.1/dim(comb)[2]
crit.mm.2 <- dist.3/dim(comb)[2]
crit.lhd.2 <- dist.2/dim(comb)[2]

# 1D
comb <- combn(1:4, 3)
dist.1 <- 0
dist.2 <- 0
dist.3 <- 0
best <- 0
for (i in 1:dim(comb)[2]) {
  dist.1 = dist.1 + criterion(mymaximin(25, 4)[,-comb[i]])  
  dist.3 = dist.3 + criterion(maximin(25, 4)[,-comb[i]])
  for (i in 1:100) {
    cand <- criterion(mylhs(25, 4)$X[,-i])
    if (cand > best) {
      best <- cand
    }
  }
  dist.2 = dist.2 + best
}
crit.mmlhd.1 <- dist.1/dim(comb)[2]
crit.mm.1 <- dist.3/dim(comb)[2]
crit.lhd.1 <- dist.2/dim(comb)[2]
```

```{r}
res <- tibble(
  `4D`=c(crit.mm.4, crit.lhd.4, crit.mmlhd.4),
  `3D`=c(crit.mm.3, crit.lhd.3, crit.mmlhd.3),
  `2D`=c(crit.mm.2, crit.lhd.2, crit.mmlhd.2),
  `1D`=c(crit.mm.1, crit.lhd.1, crit.mmlhd.1)
)
rownames(res) <- c("Maximin", "LHD", "MmLHD")
kable(res)
```

We may see from these results that the criterion is maximized best in 4D by the 
MmLHD method while in the projections the criterion is maximized better by the 
randomized LHD.

# 4.

### (a)

```{r}
inv.F <- function(x) {
  (sin(3.141592 * (x - 1/2)) + 1) / 2
}
```

We may create a scatter plot of the points generated by this process:

```{r}
X <- inv.F(mymaximin(10, 2))

ggplot(aes(x=X[,1], y=X[,2]), data=NULL) +
  geom_point() +
  labs(x="Dim 1", y="Dim 2") +
  theme_bw()
```

The points generated by this process appear to be quite space-filling. For the 
1D projections we get:

```{r}
ggplot(aes(x=X[,1], y=1), data=NULL) + 
  geom_point() +
  labs(y="") +
  theme_bw()

ggplot(aes(x=X[,2], y=1), data=NULL) + 
  geom_point() +
  labs(y="") +
  theme_bw()
```

Again, these points appear space-filling given their fairly even distribution 
across the domain of distances.

# 5.

### (a)

```{r}
dists <- array(0, c(100, 28))
for (i in 1:100) {
  d <- distance(mymaximin(8,2))
  dists[i,] <- d[upper.tri(d)]
}

ggplot() + 
  geom_histogram(aes(x=dists)) +
  theme_bw()
```

The distribution of distances is heavily right-skewed and appears bi-modal with 
the modes lying close to zero and at about 0.5.

### (b)

```{r}
betamax <- function(n, m, T=100000)
{
  X <- matrix(runif(n*m), ncol=m)     ## initial design
  dist <- distance(X)
  dist <- dist[upper.tri(dist)]
  md <- ks.test(x=dist/sqrt(2), y="pbeta", 2, 5)$statistic

  for(t in 1:T) {
    row <- sample(1:n, 1)
    xold <- X[row,]                   ## random row selection
    X[row,] <- runif(m)               ## random new row
    dist <- distance(X)
    dist <- dist[upper.tri(dist)]
    mdprime <- ks.test(x=dist/sqrt(2), y="pbeta", 2, 5)$statistic
    if(mdprime < md) { md <- mdprime  ## accept
    } else { X[row,] <- xold }        ## reject
  }

  return(X)
}
```

```{r}
dists <- c()
for (i in 1:10) {
  x <- betamax(8, 2)
  d <- distance(x)
  d <- d[upper.tri(d)]
  dists <- c(dists, d)
  plot(x)
}
```

We can see that we achieve fairly odd spacing between the points for some maximized distances.


```{r}
ggplot(aes(x=dists), data=NULL) +
  geom_histogram(bins=25) +
  theme_bw()
```

The distribution of distances produced by this procedure appears to be the desired Beta(2,5).
